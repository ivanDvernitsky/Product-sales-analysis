This notebook demonstrates how to implement a recommendation system using collaborative filtering with a dataset containing user information, such as gender, age, and artist preferences from Last.FM. For this project, we are focusing specifically on data from Germany and transforming it into a frequency matrix.

Types of Collaborative Filtering Implemented:
Item-Based Collaborative Filtering: This approach focuses on the similarities between items based on user consumption history.
User-Based Collaborative Filtering: This method compares user consumption histories and item similarities.
python
Копировать код
import pandas as pd
from scipy.spatial.distance import cosine

# Disable Jedi autocompleter
%config Completer.use_jedi = False

# Load the dataset
df = pd.read_csv('../Datasets/lastfm-matrix-germany.csv')
df.sample(5)
df.info()

# Downcast the datatypes of all columns to save memory
cols = df.columns
df[cols] = df[cols].apply(pd.to_numeric, downcast='unsigned')
df.info()
Item-Based Collaborative Filtering
For item-based filtering, the user column is unnecessary, so we remove it and focus on calculating similarities between items (artists).

python
Копировать код
# Drop the 'user' column
df_de = df.drop('user', axis=1)
df_de.info()
df_de.head()

# Create a placeholder for similarity matrix
ibcf = pd.DataFrame(index=df_de.columns, columns=df_de.columns)

# Fill the placeholder with cosine similarities
for i in range(ibcf.shape[1]):
    for j in range(ibcf.shape[1]):
        ibcf.iloc[i, j] = 1 - cosine(df_de.iloc[:, i], df_de.iloc[:, j])

ibcf.head()
This matrix shows the cosine similarity between each pair of items (artists). To make it easier to interpret, we’ll sort the columns and extract the top 10 similar items for each one.

python
Копировать код
# Create a placeholder to store the top 10 similar items
top = 10
top10 = pd.DataFrame(index=range(top), columns=ibcf.columns)

for c in ibcf.columns:
    top10[c] = ibcf[c].sort_values(ascending=False).index[1:11]

# Show top 10 similarities for the first 10 items
top10.iloc[:, :9]
User-Based Collaborative Filtering
User-based collaborative filtering recommends items by analyzing user preferences and combining them with item similarities.

Steps to create a user-based recommendation system:

Generate an item-based recommendation system.
Identify the products the user has consumed.
For each consumed item, retrieve the top X similar items.
Fetch the user's consumption history for each similar item.
Calculate a similarity score.
Recommend items with the highest scores.
We use the following formula to compute a similarity score:

python
Копировать код
# Function to calculate similarity score
def getScore(history, similarities):
    return sum(history * similarities) / sum(similarities)
Now, we apply the function to the data.

python
Копировать код
# Create a placeholder
df_sim = pd.DataFrame(index=df.index, columns=df.columns)
df_sim.iloc[:, :1] = df.iloc[:, :1]

# Loop through and calculate similarity scores
for i in range(len(df_sim.index)):
    for j in range(1, len(df_sim.columns)):
        user = df_sim.index[i]
        product = df_sim.columns[j]

        if df.iloc[i, j] == 1:
            df_sim.iloc[i, j] = 0  # Do not recommend items already consumed
        else:
            product_top_names = top10[product]
            product_top_sims = ibcf.loc[product].sort_values(ascending=False)[1:11]
            user_purchases = df_de.loc[user, product_top_names]
            
            df_sim.iloc[i, j] = getScore(user_purchases, product_top_sims)

df_sim.head()
Finally, we produce a matrix of user-based recommendations, which lists the top recommendations for each user:

python
Копировать код
# Generate user-based recommendations
recommendations = pd.DataFrame(index=df_sim.index, columns=['user', '1', '2', '3', '4', '5', '6'])
recommendations.iloc[:, 0] = df_sim.iloc[:, 0]

for i in range(len(df_sim.index)):
    recommendations.iloc[i, 1:] = df_sim.iloc[i, :].sort_values(ascending=False).iloc[1:7].index.T

recommendations.head()
Reference
S. Marafi, Collaborative Filtering with Python










